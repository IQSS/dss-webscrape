
```{r, include=FALSE, echo=FALSE}
require(knitr)
knitr::opts_chunk$set(eval=FALSE, results=TRUE, message=FALSE, warning=FALSE, error=FALSE, python.reticulate=TRUE)
# knitr::opts_chunk$set(eval=TRUE, results=TRUE, message=FALSE, warning=FALSE, error=FALSE, engine.path="c:\\Python37-x64")
require(reticulate)
# use_condaenv(condaenv="r-reticulate", required=TRUE)
```

# Filling in Web Forms
Web forms are ubiquituous when surfing the internet. A web form comprises web elements such as input boxes, check boxes, radio buttons, links, drop down menus, and submit buttons to collect user data. To process web forms, we need to first find these web elements and then take subsequent actions on them like selecting a value or entering some text. Selenium has an API that helps us to do that. Since we have covered how to find web element(s) using Selenium selectors in the previous chapter, this chapter focuses on accessing forms in Selenium: performing actions on and interacting with the forms. Let us see how different actions can be performed on each type of web field that may be involved in a web form. We use this [example login form website](https://iqssdss2020.pythonanywhere.com/tutorial/form/search) to illustrate most of the examples used in this chapter. Below is a screenshot of how this website uses forms:  

![](images/form/form.png)

## Input box
The input box is the text box that displays user input. To handle any input box, we must be able to enter information, clear information or get information from the box. To enter text into a textbox we can use the `send_keys()` method, which would input the user required text from our automation script. The following code enters the student name starting with "A" into a text box whose ID is "search_name":

```{python, eval=FALSE}
driver.find_element_by_id('search_name').send_keys("A")
```

To clear pre-entered text we can use the `clear()` method. For example:

```{python, eval=FALSE}
driver.find_element_by_id('search_name').clear()
```

If we need to validate some existing text, we can fetch text already in a text box using the `get_attribute()` method:

```{python, eval=FALSE}
nameText = driver.find_element_by_id('search_name').get_attribute("value")
print(nameText)
```

## Check box
A check box is a small box that enables us to check or uncheck it. To select or check a value we use the `click()` method. It simply changes the state from unchecked to checked and vice-versa. For example, the code below clicks on the `Accept Privacy Policy` checkbox:

```{python, eval=FALSE}
driver.find_element_by_id('privacypolicy').click()
```

Dealing with checkboxes is not always so straightforward. We may need to select a checkbox only when it is not selected already. Or, we may want to deselect a checkbox only when it is already selected. If we are trying to select a checkbox, but we perform a click operation on an already selected checkbox, then the checkbox will be deselected; something we do not want to happen. So, we first need to validate whether the checkbox is selected or not. To get the current state of the checkbox we can use one of two methods: `is_selected()` or `get_attribute("checked")`. For example, using `is_selected()`:

```{python, eval=FALSE}
privacy_boolean = driver.find_element_by_id('privacypolicy').is_selected()
print(privacy_boolean)
print(type(privacy_boolean))
```

This will return a boolean value. This means if the checkbox is checked we would get a `True` value else we will get `False` value. Alternatively, using `get_attribute("checked")`:

```{python, eval=FALSE}
privacy_other = driver.find_element_by_id('privacypolicy').get_attribute("checked")
print(privacy_other)
print(type(privacy_other))
```

This will return `True` if the checkbox is selected, but will return `NoneType` if the checkbox is not selected. The following code shows how to deselect a checkbox only when it is selected:

```{python, eval=FALSE}
driver.find_element_by_id('privacypolicy').click()
```

## Radio button
A radio button is a circular element on the screen that we can select. A radio button is similar to a checkbox, but it is only possible to select one radio button out of several choices, while we can select multiple checkboxes. The actions performed on the radio button are similar to those on a checkbox and we can use the same methods as above to select a radio button or validate its status of selection: `click()` and `is_selected()` / `get_attribute(“checked”)`. The code below provides an example:

```{python, eval=FALSE}
driver.find_element_by_id('p5').click()
pageSize_5_boolean = driver.find_element_by_id('p5').is_selected()
print(pageSize_5_boolean)
print(type(pageSize_5_boolean))

pageSize_5_other = driver.find_element_by_id('p5').get_attribute("checked")
print(pageSize_5_other)
print(type(pageSize_5_other))
```

Radio buttons do not support deselection. To deselect a radio button, one needs to select any other radio button in that group. If we select the same radio button trying to deselect it, we will get the same selection as before; nothing will change. The following code shows how to deselect a radio button only when it is selected:

```{python, eval=FALSE}
driver.find_element_by_id('p10').click()
```

## Link
A link redirects us to a new web page or a new pop-up window or a similar thing. We can use two mechanisms to navigate to a new screen or a new pop up or a new form: we can either do a click action on a link element we find, or get the new URL from the link element we find and then navigate to it. Here is an example of operating the link embedded in the example webpage using the first mechanism:

```{python, eval=FALSE}
driver.find_element_by_id("privacy_policy").click()
```

Links are generally embedded in the link element we find with a `<a>` tag name as the `"href"` property. Instead of directly clicking on the link, we can use the `get_attribute()` method. Here is the same example using the second mechanism:

```{python, eval=FALSE}
privacy_object = driver.find_element_by_id("privacy_policy")
privacy_link = privacy_object.get_attribute("href")
driver.get(privacy_link)
```

## Dropdown
A dropdown is a list which has an arrow at the rightmost end to expand and show values. It provides a list of options to the user, thereby giving access to one or multiple values as per the requirement. To work with a dropdown, first we need to select or find the main element group and then go inside further and select the sub-element that we want to capture. The Selenium Python API provides the `Select` class, which allows us to select the element of our choice. Note that the `Select` class only works with tags that have `<select>` tags. We can select a sub-element of the dropdown using: 1) index, 2) value, or 3) text.

If the dropdown has an `"index"` attribute, then we can use that index to select a particular option. We need to be careful when using this approach, because it is not uncommon to have the index start at 0. We can use the `select_by_index()` method to select an option using the `"index"` attribute. For example, we want to select the 5th grade students:

```{python, eval=FALSE}
grade_dropdown = Select(driver.find_element_by_id("search_grade"))
grade_dropdown.select_by_index(6)
```

If the HTML mark-up defines an `<option>` tag, then we can use the value matching the argument. Suppose the HTML for dropdown is like this:

```
<td>
    <select id="search_grade">
        <option selected>(no value)</option>
        <option value="K">K</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
    </select>
</td>
```

We can use the `select_by_value()` method to select an option using the `"value"` attribute.

```{python, eval=FALSE}
grade_dropdown.select_by_value("5")
```

Probably the easiest way of selecting a sub-element is to select an element using the text of the dropdown. We have to match the text that is displayed in the dropdown using the `select_by_visible_text()` method. For example:

```{python, eval=FALSE}
grade_dropdown.select_by_visible_text("5")
```

In a similar way, we can deselect any selected value from the dropdown using any of the following options: 1) `deselect_by_index()`, 2) `deselect_by_value()`, or 3) `deselect_by_visible_text()`. These methods can be used only when we make multiple selections. The `deselect_all()` method clears all the selected options. This is also only applicable when there are multiple selections. If we try to use this when there is a single selection, it will throw a `NotImplementedError` exception.

There are times while performing Selenium automation of our web app, where we need to validate the options coming in our dropdown list. The `Select` class provides property methods that allow us to do this. The first two property methods are applicable when we can select multiple options.

* `.all_selected_options` --- Get the list of all the selected options.   
* `.first_selected_option` --- Return the first option that has been selected from the dropdown and unlike the above method it would return a single web element, not a list.   
* `.is_multiple` --- Return `True` if the dropdown allows multi-selection and return `NoneType` otherwise.    
* `.options` --- Get a list of all available options in a dropdown.   

## Buttons
Buttons are simply used to submit whatever information we have filled in our forms to the server. This can be done through click actions on the button, mostly using the `click()` method:

```{python, eval=FALSE}
driver.find_element_by_id("search").click()
```

## Demos
Using our [example site](https://iqssdss2020.pythonanywhere.com/tutorial/form/search), we will examine a simple program that handles all the types of form elements we have covered so far. Second, we will examine an advanced program that handles the situation where we will need to access this form not once but many times sequentially.

### Fill form once
Suppose that we want to search all the 5th grade students whose names start with "A" and page size set at 5. The program below demonstrates how to fill in the form and submit it to the server:

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
```

### Fill form many times
Now suppose that we want to search all the students. This will require us to fill in the form many times, each time with changing input. We have to first play with the website to see if the form webpage will be refreshed every time we access it. This will determine how we are going to write our code. If the form page is refreshed every time we access it, then we have to refill all the form fields each time even if most of those fields are repetitive inputs. The program below shows an example of this use-case:

```{python, eval=FALSE}
from selenium import webdriver
import time
import string
import pandas as pd

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
searchAddress = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(searchAddress)
time.sleep(2)

students = list()

for letter in string.ascii_uppercase:
    for grade in range(2,8):
        driver.find_element_by_xpath('//*[@id="search_name"]').send_keys(letter)
        driver.find_element_by_xpath('//*[@id="search_grade"]/option[{}]'.format(grade)).click()
        driver.find_element_by_id('p5').click()
        driver.find_element_by_id("privacypolicy").click()
        driver.find_element_by_id("termsconditions").click()
        driver.find_element_by_xpath('//*[@id="search"]').click()
        time.sleep(5)
        try:
            while True:
                table = driver.find_element_by_xpath('//*[@id="results"]/table')
                entries = table.find_elements_by_tag_name("tr")
                for i in range(1, len(entries)):
                    student_dict = dict()
                    cols = entries[i].find_elements_by_tag_name("td")
                    student_dict["name"] = cols[0].text
                    student_dict["grade"] = cols[1].text
                    student_dict["gpa"] = cols[2].text
                    students.append(student_dict)

                try:
                    driver.find_element_by_xpath('//*[@id="next"]').click()
                    time.sleep(2)
                except:
                    break
            driver.get(searchAddress)
            time.sleep(2)
        except:
            print("No results for letter {} at grade {}".format(letter, grade - 2))
            driver.get(searchAddress)
            time.sleep(2)

students_df = pd.DataFrame.from_records(students)
print(students_df)
driver.close()
```

Line 39 and 43 of this program (`driver.get(searchAddress)`) indicate that the form will be refreshed whenever we finish the current search. This could happen either when we find out there is no result for this search or when we have scraped the results for this search. Since the form is refreshed every time for a new search, we need to refill the form every time when a new search starts. This is why lines 15 to 19 of the code that execute the form filling actions are put in the most inner layer of the for loop. 

To know what we need to input for a new search, we have to find out where the search has gone so far up to this point when the form is refreshed for a new search. We control the moving of rounds of search by using the indexing of a list. We put all the options for a form field into a created list with the exact order of the list elements as that being displayed in the form field. When we loop through this list, we control where the search runs through. In the above example, line 13 and 14 play this role. They control the indexing of the name list and the grade list. The name field and the grade field are the only two fields whose input values will change for a new search. This is why we need to create a list for them and then loop over it rather than doing the same thing for all the other form fields.  

Another scenario is that the form page is not refreshed for a new search. In this case, then we do not need to refill the form fields that will not change their values in a new search. Below is the program that performs the same task --– search all students --– but in the use-case where the form is not refreshed:

```{python, eval=FALSE}
from selenium import webdriver
import time
import string
import pandas as pd

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
searchAddress = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(searchAddress)
time.sleep(2)

students = list()

driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()

for letter in string.ascii_uppercase:
    driver.find_element_by_xpath('//*[@id="search_name"]').clear()
    driver.find_element_by_xpath('//*[@id="search_name"]').send_keys(letter)
    for grade in range(2,8):
        driver.find_element_by_xpath('//*[@id="search_grade"]/option[{}]'.format(grade)).click()
        driver.find_element_by_xpath('//*[@id="search"]').click()
        time.sleep(5)
        try:
            while True:
                table = driver.find_element_by_xpath('//*[@id="results"]/table')
                entries = table.find_elements_by_tag_name("tr")
                for i in range(1, len(entries)):
                    student_dict = dict()
                    cols = entries[i].find_elements_by_tag_name("td")
                    student_dict["name"] = cols[0].text
                    student_dict["grade"] = cols[1].text
                    student_dict["gpa"] = cols[2].text
                    students.append(student_dict)

                try:
                    driver.find_element_by_xpath('//*[@id="next"]').click()
                    time.sleep(2)
                except:
                    break
        except:
            print("No results for letter {} at grade {}".format(letter, grade - 2))
            
students_df = pd.DataFrame.from_records(students)
print(students_df)
driver.close()
```

There is no code in this program that refreshes the form page. We put the lines of code that fill in the constant form fields outside of the loop so that those constant fields will not be refilled in every time for a new search. The change of the positions of lines 13 –- 15 and line 19 of the code comparing the program in the first scenario reflects this idea.  

## `ElementNotInteractableException`
In some cases when the element is not interactable, actions on it as introduced in the above sections do not work and we are likely to encounter an `ElementNotInteractableException`. This is caused when an element is found, but we cannot interact with it --- for example, we may not be able to click or send keys. There could be several reasons for this scenario:

1.  The element is not visible / not displayed.   
2.  The element is off screen.   
3.  The element is behind another element or hidden.   
4.  Some other action needs to be performed by the user first to enable the element.   

There are strategies that may work to make the element interactable, depending on the circumstance. 

### Wait until clickable 
If the element has not been fully downloaded yet, we can wait until the element is visible / clickable. Look at the following example in which we want to get the profile for the 5th grade student named "Adams". 

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
table = driver.find_element_by_xpath('//*[@id="results"]/table')
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name("a").click()
```

The above code produces an error message --- `"no such element: Unable to locate element"` --- because the result table has not been fully downloaded yet. Selenium `WebDriver` provides two types of waits to handle it –-- explicit and implicit wait. The `time.sleep()` method is an **explicit wait to set the condition to be an exact time period to wait**, as the code below shows:

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select
import time

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
time.sleep(3)
table = driver.find_element_by_xpath('//*[@id="results"]/table')
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name("a").click()
```

As discussed in the previous chapter, a more efficient solution would be to make `WebDriver` **wait only as long as required**. This is also an **explicit wait** but more efficient than `time.sleep()`. The code below uses the presence of the resulting table element with id `"resulttable"` to declare that the page has been fully loaded:

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
table = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, "resulttable")))
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name("a").click()
```

The final solution is to use an **implicit wait**, which tells `WebDriver` to poll the DOM for a certain amount of time when trying to find any element(s) not immediately available. The default setting is 0. **Once set, the implicit wait is set for the life of the `WebDriver` object**. 

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
driver.implicitly_wait(10)
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
table = driver.find_element_by_xpath('//*[@id="results"]/table')
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name("a").click()
```

### Scroll until on-screen  
When an element is on screen it means that it is embedded in the DOM structure of the web page. Therefore, we can find its DOM structure when inspecting a web page. If the element we act upon is not in the DOM structure, then we will see some kind of error message. Let us look at this [example website](https://iqssdss2020.pythonanywhere.com/tutorial/casesLoad/search). Suppose that we search all the 5th grade students whose names start with "A". If we `Inspect` the HTML, we can find that there are 15 table entries included under the `<tbody>` tag in its DOM structure, as shown in the following figure: 

![](images/form/scroll.png)

Suppose that we want to get the profile for student "Aiden" --– the 15th record of the page. It will work fine. But if we want to get the profile for the 16th student of the page, we will get an error message saying `"list index out of range"`. This is because that record is off-screen. 

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select
import time

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/casesLoad/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id("search").click()
time.sleep(5)
table = driver.find_element_by_xpath('//*[@id="results"]/table')
table_body = table.find_element_by_tag_name("tbody")
entries = table_body.find_elements_by_tag_name("tr")
fields = entries[15].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name('a').click()
```

The solution is to scroll down the page so that the off-screen records can be added into its DOM structure. In the following code, we scroll down to a certain height of the page, where "5000" is the height (line 12). By uncommenting line 14 and commenting line 12, we can also scroll down to the bottom of the page:

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select
import time

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/casesLoad/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id("search").click()
time.sleep(5)
# scroll to a certain height
driver.execute_script("window.scrollTo(0, 5000)") 
# scroll to the bottom
#driver.execute_script("window.scrollTo(0, document.body.scrollHeight);") 
time.sleep(5)
table = driver.find_element_by_xpath('//*[@id="results"]/table')
table_body = table.find_element_by_tag_name("tbody")
entries = table_body.find_elements_by_tag_name("tr")
fields = entries[15].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name('a').click()
```

### Execute JavaScript
On this [example website](https://iqssdss2020.pythonanywhere.com/tutorial/formhidden/search), we can see that the form submit button is hidden. If we still use the button `click()` method, we will get an error message saying that `"element not interactable"`. In this case, we can opt to execute JavaScript that interacts directly with the DOM:

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
driver.implicitly_wait(10)
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/formhidden/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.execute_script(f'document.getElementById("search").click();')
table = driver.find_element_by_xpath('//*[@id="results"]/table')
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
fields[3].find_element_by_tag_name('a').click()
``` 

### Perform preliminary action(s)
Let us again search for all the 5th grade students whose name starts with "A" on this [example website](https://iqssdss2020.pythonanywhere.com/tutorial/form/search). If we move our cursor over a student name, we will see a hover box showing up above the name. Suppose that we want to scrape the data on the hover box. The hover box is not actionable unless we mover the cursor to a student name to enable it. Once we do that, if we inspect the webpage, we will see the hover box element has been added to its DOM structure. So, we can scrape the data on the hover box from there. In the following code segment we scrape the content on the hover box of student "Adams":

```{python, eval=FALSE}
from selenium import webdriver
from selenium.webdriver.support.select import Select
from selenium.webdriver.common.action_chains import ActionChains

driver = webdriver.Chrome('C:\\Users\\JLiu\\Desktop\\Web_Tutorial\\chromedriver.exe')
driver.implicitly_wait(10)
form_url = "https://iqssdss2020.pythonanywhere.com/tutorial/form/search"
driver.get(form_url)
driver.find_element_by_id('search_name').send_keys("A")
Select(driver.find_element_by_id("search_grade")).select_by_visible_text("5")
driver.find_element_by_id('p5').click()
driver.find_element_by_id("privacypolicy").click()
driver.find_element_by_id("termsconditions").click()
driver.find_element_by_id("search").click()
table = driver.find_element_by_xpath('//*[@id="results"]/table')
entries = table.find_elements_by_tag_name("tr")
fields = entries[1].find_elements_by_tag_name('td')
name_tag = fields[0].find_element_by_tag_name("span")
hov = ActionChains(driver).move_to_element(name_tag)
hov.perform()
hov_id = name_tag.get_attribute("aria-describedby")
print(hov_id)
hov_text = driver.find_element_by_id(hov_id).text
print(hov_text)
```

We first need to import the `ActionChains` class in Selenium `WebDriver`. We create an `ActionChains` object by passing the driver object. We then find the student name "Adams" object in the page and move the cursor on this object using the method `move_to_element()`. We then use the method `perform()` to execute the actions that we have built on the `ActionChains` object. In this case, this action makes the hover box appear above the student name. Once this is done, the hover box element is added to the DOM structure of the page. By inspecting this new addition in the DOM structure, we can find the ID of the hover box through attribute `"aria-describedby"` and therefore scrape the content of the hover box object associated with that ID.   

